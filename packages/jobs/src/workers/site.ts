import { Job } from 'bullmq';
import { prisma, PageType, PageStatus } from '@experience-marketplace/database';
import { createClaudeClient } from '@experience-marketplace/content-engine';
import type { SiteCreatePayload, SiteDeployPayload, DomainRegisterPayload, JobResult } from '../types/index.js';
import { canExecuteAutonomousOperation } from '../services/pause-control.js';
import {
  generateComprehensiveBrandIdentity,
  storeBrandIdentity,
} from '../services/brand-identity.js';

/**
 * Site Worker
 * Handles autonomous site creation and deployment
 */

interface BrandConfig {
  primaryColor?: string;
  secondaryColor?: string;
  accentColor?: string;
  font?: string;
  logoUrl?: string;
}

/**
 * Site Creation Handler
 * Creates a new micro-site with brand identity and initial structure
 */
export async function handleSiteCreate(job: Job<SiteCreatePayload>): Promise<JobResult> {
  const { opportunityId, domain, brandConfig, autoPublish = false } = job.data;

  try {
    console.log(`[Site Create] Starting site creation for opportunity ${opportunityId}`);

    // Check if autonomous site creation is allowed
    const canProceed = await canExecuteAutonomousOperation({
      feature: 'enableSiteCreation',
      rateLimitType: 'SITE_CREATE',
    });

    if (!canProceed.allowed) {
      console.log(`[Site Create] Skipping - ${canProceed.reason}`);
      return {
        success: false,
        error: canProceed.reason || 'Site creation is paused',
        errorCategory: 'paused',
        timestamp: new Date(),
      };
    }

    // 1. Validate opportunity
    const opportunity = await prisma.sEOOpportunity.findUnique({
      where: { id: opportunityId },
    });

    if (!opportunity) {
      throw new Error(`Opportunity ${opportunityId} not found`);
    }

    if (opportunity.siteId) {
      throw new Error(`Opportunity ${opportunityId} already assigned to a site`);
    }

    // Allow IDENTIFIED, EVALUATED, or ASSIGNED (auto-actioned opportunities get marked ASSIGNED when job is queued)
    if (!['IDENTIFIED', 'EVALUATED', 'ASSIGNED'].includes(opportunity.status)) {
      throw new Error(`Opportunity ${opportunityId} not in correct status for site creation`);
    }

    // 2. Generate comprehensive brand identity
    console.log('[Site Create] Generating comprehensive brand identity...');
    const brandIdentity = await generateComprehensiveBrandIdentity(
      {
        keyword: opportunity.keyword,
        location: opportunity.location || undefined,
        niche: opportunity.niche,
        searchVolume: opportunity.searchVolume,
        intent: opportunity.intent,
      },
      brandConfig
        ? {
            name: brandConfig.name,
            primaryColor: brandConfig.primaryColor,
            secondaryColor: brandConfig.secondaryColor,
            accentColor: brandConfig.accentColor,
            headingFont: brandConfig.font,
            bodyFont: brandConfig.font,
            logoUrl: brandConfig.logoUrl || null,
          }
        : undefined
    );

    console.log(`[Site Create] Generated brand: "${brandIdentity.name}" - ${brandIdentity.tagline}`);

    // 3. Create site record with comprehensive brand
    console.log('[Site Create] Creating site record...');
    const slug = generateSlug(brandIdentity.name);

    // Check for slug collision
    const existingSite = await prisma.site.findUnique({ where: { slug } });
    const finalSlug = existingSite ? `${slug}-${Math.random().toString(36).substring(7)}` : slug;

    const site = await prisma.site.create({
      data: {
        name: brandIdentity.name,
        slug: finalSlug,
        description: brandIdentity.tagline,
        isAutomatic: true,
        holibobPartnerId: process.env['HOLIBOB_PARTNER_ID'] || '',
        status: 'DRAFT',
        brand: {
          create: {
            name: brandIdentity.name,
            tagline: brandIdentity.tagline,
            primaryColor: brandIdentity.primaryColor,
            secondaryColor: brandIdentity.secondaryColor,
            accentColor: brandIdentity.accentColor,
            headingFont: brandIdentity.headingFont,
            bodyFont: brandIdentity.bodyFont,
            logoUrl: brandIdentity.logoUrl,
            isAutoGenerated: true,
            generationPrompt: `Comprehensive brand identity for ${opportunity.niche} in ${opportunity.location}`,
          },
        },
      },
      include: {
        brand: true,
      },
    });

    // 4. Store extended brand identity in seoConfig
    await storeBrandIdentity(site.id, site.brand?.id || '', brandIdentity);

    console.log(`[Site Create] Created site ${site.id} with slug ${site.slug}`);
    console.log(`[Site Create] Brand stored with tone: ${brandIdentity.toneOfVoice.personality.join(', ')}`);

    // 5. Create initial page structure
    console.log('[Site Create] Creating initial pages...');
    const pages = await createInitialPages(site.id, opportunity);

    // 6. Link opportunity to site
    await prisma.sEOOpportunity.update({
      where: { id: opportunityId },
      data: {
        siteId: site.id,
        status: 'ASSIGNED',
      },
    });

    console.log(`[Site Create] Linked opportunity ${opportunityId} to site ${site.id}`);

    // 7. Queue content generation jobs with brand context
    console.log('[Site Create] Queuing content generation jobs with brand guidelines...');
    const { addJob } = await import('../queues/index.js');

    // Homepage content - will use brand tone of voice and trust signals
    await addJob('CONTENT_GENERATE', {
      siteId: site.id,
      opportunityId,
      contentType: 'destination',
      targetKeyword: opportunity.keyword,
      secondaryKeywords: brandIdentity.contentGuidelines.semanticKeywords.slice(0, 5),
    });

    console.log('[Site Create] Queued homepage content generation with brand context');

    // 8. Queue domain registration
    // Use provided domain or generate from site slug
    const suggestedDomain = domain || `${site.slug}.com`;
    console.log(`[Site Create] Queuing domain registration for ${suggestedDomain}...`);

    const domainPayload: DomainRegisterPayload = {
      siteId: site.id,
      domain: suggestedDomain,
      registrar: 'cloudflare',
      autoRenew: true,
    };

    await addJob('DOMAIN_REGISTER', domainPayload, {
      priority: 4, // Medium-high priority
      delay: 5000, // Small delay to let site creation settle
    });

    console.log(`[Site Create] Queued domain registration for ${suggestedDomain}`);

    // 9. Queue deployment if auto-publish enabled
    if (autoPublish) {
      console.log('[Site Create] Auto-publish enabled, queuing deployment...');
      await addJob('SITE_DEPLOY', {
        siteId: site.id,
        environment: 'staging',
      });
    }

    return {
      success: true,
      message: `Site created successfully: ${site.name}`,
      data: {
        siteId: site.id,
        slug: site.slug,
        brandId: site.brand?.id,
        pagesCreated: pages.length,
        suggestedDomain,
        autoPublish,
      },
      timestamp: new Date(),
    };
  } catch (error) {
    console.error('[Site Create] Error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      timestamp: new Date(),
    };
  }
}

/**
 * Site Deployment Handler
 * Deploys site to staging/production environment
 */
export async function handleSiteDeploy(job: Job<SiteDeployPayload>): Promise<JobResult> {
  const { siteId, environment = 'staging' } = job.data;

  try {
    console.log(`[Site Deploy] Starting deployment for site ${siteId} to ${environment}`);

    // 1. Validate site
    const site = await prisma.site.findUnique({
      where: { id: siteId },
      include: {
        brand: true,
        domains: true,
        pages: true,
      },
    });

    if (!site) {
      throw new Error(`Site ${siteId} not found`);
    }

    if (site.status === 'ARCHIVED') {
      throw new Error(`Site ${siteId} is archived`);
    }

    // 2. Check deployment readiness
    const publishedPages = site.pages.filter((p) => p.status === 'PUBLISHED');
    if (publishedPages.length === 0) {
      throw new Error(`Site ${siteId} has no published pages`);
    }

    if (!site.brand) {
      throw new Error(`Site ${siteId} has no brand configuration`);
    }

    // 3. Determine deployment URL
    let deploymentUrl: string;

    if (environment === 'staging') {
      // For staging, use Heroku-provided URL or subdomain
      deploymentUrl = `https://${site.slug}.herokuapp.com`;
    } else {
      // For production, require custom domain
      const primaryDomain = site.domains.find((d) => site.primaryDomain === d.domain);
      if (!primaryDomain || !primaryDomain.verifiedAt) {
        throw new Error(`Site ${siteId} requires verified custom domain for production deployment`);
      }
      deploymentUrl = `https://${primaryDomain.domain}`;
    }

    // 4. For MVP, update site metadata rather than actually deploying
    // TODO: Implement actual Heroku deployment in Phase 3
    console.log(`[Site Deploy] Updating site metadata with deployment URL: ${deploymentUrl}`);

    const updatedSite = await prisma.site.update({
      where: { id: siteId },
      data: {
        status: environment === 'production' ? 'ACTIVE' : 'DRAFT',
        // Store deployment info in custom JSON field if available, or just log
      },
    });

    console.log(`[Site Deploy] Site ${siteId} status updated to ${updatedSite.status}`);

    // 5. Post-deployment tasks
    if (environment === 'production') {
      console.log('[Site Deploy] Queuing post-deployment tasks...');

      // Submit sitemap to GSC
      const { addJob } = await import('../queues/index.js');
      await addJob('GSC_SYNC', {
        siteId,
      });

      // Start metrics tracking
      await addJob('METRICS_AGGREGATE', {
        siteId,
        aggregationType: 'daily',
      });

      console.log('[Site Deploy] Post-deployment tasks queued');
    }

    return {
      success: true,
      message: `Site deployed to ${environment}`,
      data: {
        siteId,
        environment,
        deploymentUrl,
        status: updatedSite.status,
        publishedPages: publishedPages.length,
      },
      timestamp: new Date(),
    };
  } catch (error) {
    console.error('[Site Deploy] Error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      timestamp: new Date(),
    };
  }
}

// Helper Functions

async function generateBrandIdentity(
  opportunity: any,
  providedConfig?: BrandConfig
): Promise<{
  name: string;
  tagline: string;
  primaryColor: string;
  secondaryColor: string;
  accentColor: string;
  font: string;
  logoUrl: string | null;
}> {
  // If brand config provided, use it with defaults
  if (providedConfig) {
    return {
      name: extractBrandName(opportunity),
      tagline: `Discover ${opportunity.niche} in ${opportunity.location}`,
      primaryColor: providedConfig.primaryColor || '#6366f1',
      secondaryColor: providedConfig.secondaryColor || '#8b5cf6',
      accentColor: providedConfig.accentColor || '#ec4899',
      font: providedConfig.font || 'Inter',
      logoUrl: providedConfig.logoUrl || null,
    };
  }

  // Generate brand with AI
  try {
    const client = createClaudeClient({
      apiKey: process.env['ANTHROPIC_API_KEY'] || process.env['CLAUDE_API_KEY'] || '',
    });

    const prompt = `Generate a brand identity for a travel experience marketplace focusing on:
- Location: ${opportunity.location}
- Niche: ${opportunity.niche}
- Keyword: ${opportunity.keyword}

Provide a brand identity with:
1. Brand name (creative, memorable, 1-3 words)
2. Tagline (compelling, under 60 characters)
3. Primary color (hex code, vibrant)
4. Secondary color (hex code, complementary)
5. Accent color (hex code, for CTAs)
6. Font family (Google Fonts name)

Format as JSON:
{
  "name": "Brand Name",
  "tagline": "Compelling tagline",
  "primaryColor": "#hexcode",
  "secondaryColor": "#hexcode",
  "accentColor": "#hexcode",
  "font": "Font Name"
}`;

    const response = await client.generate({
      model: client.getModelId('sonnet'),
      messages: [{ role: 'user', content: prompt }],
      maxTokens: 500,
      temperature: 0.9, // Higher temperature for creativity
    });

    const content = response.content[0]?.type === 'text' ? response.content[0].text : '';
    const jsonMatch = content.match(/\{[\s\S]*\}/);

    if (jsonMatch) {
      const generated = JSON.parse(jsonMatch[0]);
      return {
        name: generated.name || extractBrandName(opportunity),
        tagline: generated.tagline || `Discover ${opportunity.niche} in ${opportunity.location}`,
        primaryColor: generated.primaryColor || '#6366f1',
        secondaryColor: generated.secondaryColor || '#8b5cf6',
        accentColor: generated.accentColor || '#ec4899',
        font: generated.font || 'Inter',
        logoUrl: null,
      };
    }
  } catch (error) {
    console.error('[Site Create] AI brand generation failed:', error);
  }

  // Fallback to template-based brand
  return {
    name: extractBrandName(opportunity),
    tagline: `Discover ${opportunity.niche} in ${opportunity.location}`,
    primaryColor: '#6366f1',
    secondaryColor: '#8b5cf6',
    accentColor: '#ec4899',
    font: 'Inter',
    logoUrl: null,
  };
}

function extractBrandName(opportunity: any): string {
  const location = (opportunity.location || '').split(',')[0]?.trim();
  const niche = (opportunity.niche || '').trim();

  // Generate simple brand name
  if (location && niche) {
    return `${location} ${capitalize(niche)}`;
  }

  return 'Experience Marketplace';
}

function capitalize(str: string): string {
  return str
    .split(' ')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

function generateSlug(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '');
}

async function createInitialPages(siteId: string, opportunity: any) {
  const pages = [
    {
      siteId,
      title: 'Home',
      slug: '',
      type: PageType.HOMEPAGE,
      status: PageStatus.DRAFT,
    },
    {
      siteId,
      title: 'About Us',
      slug: 'about',
      type: PageType.ABOUT,
      status: PageStatus.DRAFT,
    },
    {
      siteId,
      title: 'Contact',
      slug: 'contact',
      type: PageType.CONTACT,
      status: PageStatus.DRAFT,
    },
    {
      siteId,
      title: 'Privacy Policy',
      slug: 'privacy',
      type: PageType.LEGAL,
      status: PageStatus.DRAFT,
    },
    {
      siteId,
      title: 'Terms of Service',
      slug: 'terms',
      type: PageType.LEGAL,
      status: PageStatus.DRAFT,
    },
  ];

  const createdPages = [];
  for (const pageData of pages) {
    const page = await prisma.page.create({ data: pageData });
    createdPages.push(page);
  }

  return createdPages;
}
