import { Job } from 'bullmq';
import { prisma, PageType, PageStatus } from '@experience-marketplace/database';
import { createClaudeClient } from '@experience-marketplace/content-engine';
import type { SiteCreatePayload, SiteDeployPayload, DomainRegisterPayload, JobResult } from '../types/index.js';
import { canExecuteAutonomousOperation } from '../services/pause-control.js';
import {
  generateComprehensiveBrandIdentity,
  storeBrandIdentity,
  generateHomepageConfig,
  storeHomepageConfig,
  generateSeoTitleConfig,
} from '../services/brand-identity.js';
import { generateAndStoreFavicon } from '../services/favicon-generator.js';
import { initializeSiteRoadmap } from '../services/site-roadmap.js';
import { CloudflareRegistrarService } from '../services/cloudflare-registrar.js';
import { generateBlogTopics } from '../services/blog-topics.js';

/**
 * Site Worker
 * Handles autonomous site creation and deployment
 */

interface BrandConfig {
  primaryColor?: string;
  secondaryColor?: string;
  accentColor?: string;
  font?: string;
  logoUrl?: string;
}

/**
 * Site Creation Handler
 * Creates a new micro-site with brand identity and initial structure
 */
export async function handleSiteCreate(job: Job<SiteCreatePayload>): Promise<JobResult> {
  const { opportunityId, domain, brandConfig, autoPublish = false } = job.data;

  try {
    console.log(`[Site Create] Starting site creation for opportunity ${opportunityId}`);

    // Check if autonomous site creation is allowed
    const canProceed = await canExecuteAutonomousOperation({
      feature: 'enableSiteCreation',
      rateLimitType: 'SITE_CREATE',
    });

    if (!canProceed.allowed) {
      console.log(`[Site Create] Skipping - ${canProceed.reason}`);
      return {
        success: false,
        error: canProceed.reason || 'Site creation is paused',
        errorCategory: 'paused',
        timestamp: new Date(),
      };
    }

    // 1. Validate opportunity
    const opportunity = await prisma.sEOOpportunity.findUnique({
      where: { id: opportunityId },
    });

    if (!opportunity) {
      throw new Error(`Opportunity ${opportunityId} not found`);
    }

    if (opportunity.siteId) {
      throw new Error(`Opportunity ${opportunityId} already assigned to a site`);
    }

    // Allow IDENTIFIED, EVALUATED, or ASSIGNED (auto-actioned opportunities get marked ASSIGNED when job is queued)
    if (!['IDENTIFIED', 'EVALUATED', 'ASSIGNED'].includes(opportunity.status)) {
      throw new Error(`Opportunity ${opportunityId} not in correct status for site creation`);
    }

    // 2. Generate comprehensive brand identity
    console.log('[Site Create] Generating comprehensive brand identity...');
    const brandIdentity = await generateComprehensiveBrandIdentity(
      {
        keyword: opportunity.keyword,
        location: opportunity.location || undefined,
        niche: opportunity.niche,
        searchVolume: opportunity.searchVolume,
        intent: opportunity.intent,
      },
      brandConfig
        ? {
            name: brandConfig.name,
            primaryColor: brandConfig.primaryColor,
            secondaryColor: brandConfig.secondaryColor,
            accentColor: brandConfig.accentColor,
            headingFont: brandConfig.font,
            bodyFont: brandConfig.font,
            logoUrl: brandConfig.logoUrl || null,
          }
        : undefined
    );

    console.log(`[Site Create] Generated brand: "${brandIdentity.name}" - ${brandIdentity.tagline}`);

    // 3. Create site record with comprehensive brand
    console.log('[Site Create] Creating site record...');
    const slug = generateSlug(brandIdentity.name);

    // Check for slug collision
    const existingSite = await prisma.site.findUnique({ where: { slug } });
    const finalSlug = existingSite ? `${slug}-${Math.random().toString(36).substring(7)}` : slug;

    const site = await prisma.site.create({
      data: {
        name: brandIdentity.name,
        slug: finalSlug,
        description: brandIdentity.tagline,
        isAutomatic: true,
        holibobPartnerId: process.env['HOLIBOB_PARTNER_ID'] || '',
        status: 'DRAFT',
        brand: {
          create: {
            name: brandIdentity.name,
            tagline: brandIdentity.tagline,
            primaryColor: brandIdentity.primaryColor,
            secondaryColor: brandIdentity.secondaryColor,
            accentColor: brandIdentity.accentColor,
            headingFont: brandIdentity.headingFont,
            bodyFont: brandIdentity.bodyFont,
            logoUrl: brandIdentity.logoUrl,
            isAutoGenerated: true,
            generationPrompt: `Comprehensive brand identity for ${opportunity.niche} in ${opportunity.location}`,
          },
        },
      },
      include: {
        brand: true,
      },
    });

    // 4. Store extended brand identity in seoConfig with SEO title config
    const seoTitleConfig = generateSeoTitleConfig({
      brandName: brandIdentity.name,
      niche: opportunity.niche,
      location: opportunity.location || undefined,
      keyword: opportunity.keyword,
      tagline: brandIdentity.tagline,
    });
    await storeBrandIdentity(site.id, site.brand?.id || '', brandIdentity, seoTitleConfig);

    console.log(`[Site Create] Created site ${site.id} with slug ${site.slug}`);
    console.log(`[Site Create] Brand stored with tone: ${brandIdentity.toneOfVoice.personality.join(', ')}`);
    console.log(`[Site Create] SEO title: "${seoTitleConfig.defaultTitle}"`);

    // 4.1 Generate and store favicon
    try {
      await generateAndStoreFavicon(
        site.brand?.id || '',
        brandIdentity.name,
        brandIdentity.primaryColor
      );
    } catch (faviconError) {
      console.warn('[Site Create] Favicon generation failed (non-critical):', faviconError);
    }

    // 4.2 Generate and store homepage configuration
    console.log('[Site Create] Generating homepage configuration...');
    const homepageConfig = await generateHomepageConfig(
      {
        keyword: opportunity.keyword,
        location: opportunity.location || undefined,
        niche: opportunity.niche,
        searchVolume: opportunity.searchVolume,
        intent: opportunity.intent,
      },
      brandIdentity
    );

    await storeHomepageConfig(site.id, homepageConfig);
    console.log(`[Site Create] Homepage config stored with destination: ${homepageConfig.popularExperiences?.destination || 'none'}`);

    // 4.5 Initialize site roadmap with planned tasks
    await initializeSiteRoadmap(site.id);

    // 5. Create initial page structure
    console.log('[Site Create] Creating initial pages...');
    const pages = await createInitialPages(site.id, opportunity);

    // 6. Link opportunity to site
    await prisma.sEOOpportunity.update({
      where: { id: opportunityId },
      data: {
        siteId: site.id,
        status: 'ASSIGNED',
      },
    });

    console.log(`[Site Create] Linked opportunity ${opportunityId} to site ${site.id}`);

    // 7. Queue content generation jobs with brand context
    console.log('[Site Create] Queuing content generation jobs with brand guidelines...');
    const { addJob } = await import('../queues/index.js');

    // Homepage content - will use brand tone of voice and trust signals
    await addJob('CONTENT_GENERATE', {
      siteId: site.id,
      opportunityId,
      contentType: 'destination',
      targetKeyword: opportunity.keyword,
      secondaryKeywords: brandIdentity.contentGuidelines.semanticKeywords.slice(0, 5),
    });

    console.log('[Site Create] Queued homepage content generation with brand context');

    // Queue content generation for About page
    const aboutPage = pages.find((p) => p.slug === 'about');
    if (aboutPage) {
      await addJob('CONTENT_GENERATE', {
        siteId: site.id,
        pageId: aboutPage.id,
        contentType: 'about', // Dedicated about type with strict factual guardrails
        targetKeyword: `About ${brandIdentity.name}`,
        secondaryKeywords: [opportunity.niche, 'travel experiences', opportunity.location || ''].filter(Boolean),
      });
      console.log('[Site Create] Queued About page content generation (with factual guardrails)');
    }

    // Queue content generation for Contact page
    const contactPage = pages.find((p) => p.slug === 'contact');
    if (contactPage) {
      await addJob('CONTENT_GENERATE', {
        siteId: site.id,
        pageId: contactPage.id,
        contentType: 'blog',
        targetKeyword: `Contact ${brandIdentity.name}`,
        secondaryKeywords: ['customer support', 'get in touch', 'help'],
      });
      console.log('[Site Create] Queued Contact page content generation');
    }

    // Queue content generation for Privacy Policy
    const privacyPage = pages.find((p) => p.slug === 'privacy');
    if (privacyPage) {
      await addJob('CONTENT_GENERATE', {
        siteId: site.id,
        pageId: privacyPage.id,
        contentType: 'blog',
        targetKeyword: `Privacy Policy for ${brandIdentity.name}`,
        secondaryKeywords: ['data protection', 'UK GDPR', 'personal information'],
      });
      console.log('[Site Create] Queued Privacy Policy content generation');
    }

    // Queue content generation for Terms of Service
    const termsPage = pages.find((p) => p.slug === 'terms');
    if (termsPage) {
      await addJob('CONTENT_GENERATE', {
        siteId: site.id,
        pageId: termsPage.id,
        contentType: 'blog',
        targetKeyword: `Terms of Service for ${brandIdentity.name}`,
        secondaryKeywords: ['booking terms', 'UK consumer law', 'conditions'],
      });
      console.log('[Site Create] Queued Terms of Service content generation');
    }

    // 7.5 Generate initial blog posts for SEO
    console.log('[Site Create] Generating initial blog topics...');
    try {
      const blogTopics = await generateBlogTopics(
        {
          siteName: brandIdentity.name,
          niche: opportunity.niche,
          location: opportunity.location || undefined,
          destination: opportunity.location || undefined,
        },
        5 // Generate 5 initial blog topics
      );

      console.log(`[Site Create] Generated ${blogTopics.length} blog topics`);

      // Create blog pages and queue content generation
      for (const topic of blogTopics) {
        const blogPage = await prisma.page.create({
          data: {
            siteId: site.id,
            title: topic.title,
            slug: `blog/${topic.slug}`,
            type: PageType.BLOG,
            status: PageStatus.DRAFT,
            metaDescription: `${topic.targetKeyword} - ${brandIdentity.name}`,
          },
        });

        // Queue content generation for each blog post
        await addJob('CONTENT_GENERATE', {
          siteId: site.id,
          pageId: blogPage.id,
          contentType: 'blog',
          targetKeyword: topic.targetKeyword,
          secondaryKeywords: topic.secondaryKeywords,
        });

        console.log(`[Site Create] Queued blog post: "${topic.title}"`);
      }

      console.log(`[Site Create] Created and queued ${blogTopics.length} initial blog posts`);
    } catch (blogError) {
      // Blog generation is non-critical, log and continue
      console.error('[Site Create] Failed to generate blog topics:', blogError);
    }

    // 8. Check domain availability and create domain record
    // Use provided domain or generate from site slug
    const suggestedDomain = domain || `${site.slug}.com`;
    console.log(`[Site Create] Checking domain availability for ${suggestedDomain}...`);

    const availabilityResult = await checkDomainAvailabilityForSite(suggestedDomain);

    // Create domain record with availability status
    // Available domains get AVAILABLE status (price stored for manual approval check in admin UI)
    // Unavailable domains get NOT_AVAILABLE status
    // Note: Using 'as any' until Prisma client is regenerated with new enum values
    const domainRecord = await prisma.domain.create({
      data: {
        domain: suggestedDomain,
        status: (availabilityResult.available ? 'AVAILABLE' : 'NOT_AVAILABLE') as any,
        registrar: 'cloudflare',
        registrationCost: availabilityResult.price ?? 9.77,
        siteId: site.id,
      },
    });

    const priceDisplay = availabilityResult.price?.toFixed(2) || 'unknown';
    console.log(`[Site Create] Domain ${suggestedDomain} status: ${domainRecord.status} (price: $${priceDisplay})`);

    // Only queue registration if available and under $10 limit
    const MAX_AUTO_PURCHASE_PRICE = 10;
    if (availabilityResult.available && (!availabilityResult.price || availabilityResult.price <= MAX_AUTO_PURCHASE_PRICE)) {
      console.log(`[Site Create] Queuing domain registration for ${suggestedDomain}...`);

      const domainPayload: DomainRegisterPayload = {
        siteId: site.id,
        domain: suggestedDomain,
        registrar: 'cloudflare',
        autoRenew: true,
      };

      await addJob('DOMAIN_REGISTER', domainPayload, {
        priority: 4, // Medium-high priority
        delay: 5000, // Small delay to let site creation settle
      });

      console.log(`[Site Create] Queued domain registration for ${suggestedDomain}`);
    } else if (!availabilityResult.available) {
      console.log(`[Site Create] Domain ${suggestedDomain} is NOT AVAILABLE - requires manual review for alternative domain`);
    } else {
      console.log(`[Site Create] Domain ${suggestedDomain} costs $${availabilityResult.price?.toFixed(2)} (over $${MAX_AUTO_PURCHASE_PRICE} limit) - requires manual approval`);
    }

    // 9. Queue GA4 setup for analytics tracking
    console.log('[Site Create] Queuing GA4 analytics setup...');
    await addJob('GA4_SETUP', {
      siteId: site.id,
    }, {
      priority: 5,
      delay: 10000, // Small delay to let other setup settle
    });
    console.log('[Site Create] Queued GA4 setup job');

    // 10. Queue deployment if auto-publish enabled
    if (autoPublish) {
      console.log('[Site Create] Auto-publish enabled, queuing deployment...');
      await addJob('SITE_DEPLOY', {
        siteId: site.id,
        environment: 'staging',
      });
    }

    return {
      success: true,
      message: `Site created successfully: ${site.name}`,
      data: {
        siteId: site.id,
        slug: site.slug,
        brandId: site.brand?.id,
        pagesCreated: pages.length,
        suggestedDomain,
        autoPublish,
      },
      timestamp: new Date(),
    };
  } catch (error) {
    console.error('[Site Create] Error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      timestamp: new Date(),
    };
  }
}

/**
 * Site Deployment Handler
 * Deploys site to staging/production environment
 */
export async function handleSiteDeploy(job: Job<SiteDeployPayload>): Promise<JobResult> {
  const { siteId, environment = 'staging' } = job.data;

  try {
    console.log(`[Site Deploy] Starting deployment for site ${siteId} to ${environment}`);

    // 1. Validate site
    const site = await prisma.site.findUnique({
      where: { id: siteId },
      include: {
        brand: true,
        domains: true,
        pages: true,
      },
    });

    if (!site) {
      throw new Error(`Site ${siteId} not found`);
    }

    if (site.status === 'ARCHIVED') {
      throw new Error(`Site ${siteId} is archived`);
    }

    // 2. Check deployment readiness
    const publishedPages = site.pages.filter((p) => p.status === 'PUBLISHED');
    if (publishedPages.length === 0) {
      throw new Error(`Site ${siteId} has no published pages`);
    }

    if (!site.brand) {
      throw new Error(`Site ${siteId} has no brand configuration`);
    }

    // 3. Determine deployment URL
    let deploymentUrl: string;

    if (environment === 'staging') {
      // For staging, use Heroku-provided URL or subdomain
      deploymentUrl = `https://${site.slug}.herokuapp.com`;
    } else {
      // For production, require custom domain
      const primaryDomain = site.domains.find((d) => site.primaryDomain === d.domain);
      if (!primaryDomain || !primaryDomain.verifiedAt) {
        throw new Error(`Site ${siteId} requires verified custom domain for production deployment`);
      }
      deploymentUrl = `https://${primaryDomain.domain}`;
    }

    // 4. For MVP, update site metadata rather than actually deploying
    // TODO: Implement actual Heroku deployment in Phase 3
    console.log(`[Site Deploy] Updating site metadata with deployment URL: ${deploymentUrl}`);

    const updatedSite = await prisma.site.update({
      where: { id: siteId },
      data: {
        status: environment === 'production' ? 'ACTIVE' : 'DRAFT',
        // Store deployment info in custom JSON field if available, or just log
      },
    });

    console.log(`[Site Deploy] Site ${siteId} status updated to ${updatedSite.status}`);

    // 5. Post-deployment tasks
    if (environment === 'production') {
      console.log('[Site Deploy] Queuing post-deployment tasks...');

      // Submit sitemap to GSC
      const { addJob } = await import('../queues/index.js');
      await addJob('GSC_SYNC', {
        siteId,
      });

      // Start metrics tracking
      await addJob('METRICS_AGGREGATE', {
        siteId,
        aggregationType: 'daily',
      });

      console.log('[Site Deploy] Post-deployment tasks queued');
    }

    return {
      success: true,
      message: `Site deployed to ${environment}`,
      data: {
        siteId,
        environment,
        deploymentUrl,
        status: updatedSite.status,
        publishedPages: publishedPages.length,
      },
      timestamp: new Date(),
    };
  } catch (error) {
    console.error('[Site Deploy] Error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      timestamp: new Date(),
    };
  }
}

// Helper Functions

async function generateBrandIdentity(
  opportunity: any,
  providedConfig?: BrandConfig
): Promise<{
  name: string;
  tagline: string;
  primaryColor: string;
  secondaryColor: string;
  accentColor: string;
  font: string;
  logoUrl: string | null;
}> {
  // If brand config provided, use it with defaults
  if (providedConfig) {
    return {
      name: extractBrandName(opportunity),
      tagline: `Discover ${opportunity.niche} in ${opportunity.location}`,
      primaryColor: providedConfig.primaryColor || '#6366f1',
      secondaryColor: providedConfig.secondaryColor || '#8b5cf6',
      accentColor: providedConfig.accentColor || '#ec4899',
      font: providedConfig.font || 'Inter',
      logoUrl: providedConfig.logoUrl || null,
    };
  }

  // Generate brand with AI
  try {
    const client = createClaudeClient({
      apiKey: process.env['ANTHROPIC_API_KEY'] || process.env['CLAUDE_API_KEY'] || '',
    });

    const prompt = `Generate a brand identity for a travel experience marketplace focusing on:
- Location: ${opportunity.location}
- Niche: ${opportunity.niche}
- Keyword: ${opportunity.keyword}

Provide a brand identity with:
1. Brand name (creative, memorable, 1-3 words)
2. Tagline (compelling, under 60 characters)
3. Primary color (hex code, vibrant)
4. Secondary color (hex code, complementary)
5. Accent color (hex code, for CTAs)
6. Font family (Google Fonts name)

Format as JSON:
{
  "name": "Brand Name",
  "tagline": "Compelling tagline",
  "primaryColor": "#hexcode",
  "secondaryColor": "#hexcode",
  "accentColor": "#hexcode",
  "font": "Font Name"
}`;

    const response = await client.generate({
      model: client.getModelId('sonnet'),
      messages: [{ role: 'user', content: prompt }],
      maxTokens: 500,
      temperature: 0.9, // Higher temperature for creativity
    });

    const content = response.content[0]?.type === 'text' ? response.content[0].text : '';
    const jsonMatch = content.match(/\{[\s\S]*\}/);

    if (jsonMatch) {
      const generated = JSON.parse(jsonMatch[0]);
      return {
        name: generated.name || extractBrandName(opportunity),
        tagline: generated.tagline || `Discover ${opportunity.niche} in ${opportunity.location}`,
        primaryColor: generated.primaryColor || '#6366f1',
        secondaryColor: generated.secondaryColor || '#8b5cf6',
        accentColor: generated.accentColor || '#ec4899',
        font: generated.font || 'Inter',
        logoUrl: null,
      };
    }
  } catch (error) {
    console.error('[Site Create] AI brand generation failed:', error);
  }

  // Fallback to template-based brand
  return {
    name: extractBrandName(opportunity),
    tagline: `Discover ${opportunity.niche} in ${opportunity.location}`,
    primaryColor: '#6366f1',
    secondaryColor: '#8b5cf6',
    accentColor: '#ec4899',
    font: 'Inter',
    logoUrl: null,
  };
}

function extractBrandName(opportunity: any): string {
  const location = (opportunity.location || '').split(',')[0]?.trim();
  const niche = (opportunity.niche || '').trim();

  // Generate simple brand name
  if (location && niche) {
    return `${location} ${capitalize(niche)}`;
  }

  return 'Experience Marketplace';
}

function capitalize(str: string): string {
  return str
    .split(' ')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

function generateSlug(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '');
}

/**
 * Check domain availability via Cloudflare API
 * Returns availability status and price for the autonomous flow
 */
async function checkDomainAvailabilityForSite(
  domain: string
): Promise<{ available: boolean; price?: number }> {
  console.log(`[Site Create] Checking availability for ${domain}`);

  try {
    const registrarService = new CloudflareRegistrarService();
    const result = await registrarService.checkAvailability(domain);

    console.log(`[Site Create] Domain ${domain} availability: ${result.available}, price: $${result.price?.toFixed(2) || 'unknown'}`);

    return {
      available: result.available,
      price: result.price,
    };
  } catch (error) {
    console.error(`[Site Create] Error checking domain availability:`, error);

    // On error, return as pending (unknown availability)
    // Domain registration job will re-check at registration time
    return {
      available: false,
      price: undefined,
    };
  }
}

async function createInitialPages(siteId: string, opportunity: any) {
  const pages = [
    {
      siteId,
      title: 'Home',
      slug: '',
      type: PageType.HOMEPAGE,
      status: PageStatus.DRAFT,
    },
    {
      siteId,
      title: 'About Us',
      slug: 'about',
      type: PageType.ABOUT,
      status: PageStatus.DRAFT,
    },
    {
      siteId,
      title: 'Contact',
      slug: 'contact',
      type: PageType.CONTACT,
      status: PageStatus.DRAFT,
    },
    {
      siteId,
      title: 'Privacy Policy',
      slug: 'privacy',
      type: PageType.LEGAL,
      status: PageStatus.DRAFT,
    },
    {
      siteId,
      title: 'Terms of Service',
      slug: 'terms',
      type: PageType.LEGAL,
      status: PageStatus.DRAFT,
    },
  ];

  const createdPages = [];
  for (const pageData of pages) {
    const page = await prisma.page.create({ data: pageData });
    createdPages.push(page);
  }

  return createdPages;
}
