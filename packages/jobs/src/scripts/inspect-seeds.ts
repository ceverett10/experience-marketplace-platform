/**
 * Inspect the actual keyword seeds generated by enrichment.
 * Shows seeds grouped by supplier for quality review.
 *
 * Usage: node packages/jobs/dist/scripts/inspect-seeds.js [supplierCount]
 */
import { prisma } from '@experience-marketplace/database';
import { createHolibobClient, type Product as HolibobProduct } from '@experience-marketplace/holibob-api';

const TRANSPORT_CATEGORIES = new Set([
  'transfer', 'car, bus or mini-van', 'transportation', 'shuttle',
  'airport transfer', 'port transfer',
]);

const KNOWN_DESTINATIONS = new Set([
  'london', 'paris', 'barcelona', 'rome', 'amsterdam', 'lisbon', 'madrid',
  'berlin', 'vienna', 'prague', 'budapest', 'dublin', 'edinburgh', 'athens',
  'florence', 'venice', 'milan', 'naples', 'seville', 'porto', 'nice',
  'munich', 'bruges', 'dubrovnik', 'split', 'york', 'cambridge',
  'glasgow', 'liverpool', 'manchester', 'bath', 'oxford',
  'tokyo', 'kyoto', 'osaka', 'bangkok', 'singapore', 'hong kong',
  'bali', 'dubai', 'colombo', 'kandy', 'cairo', 'cape town',
  'sydney', 'melbourne', 'auckland', 'queenstown',
  'bologna', 'palermo', 'siena', 'verona', 'turin', 'genoa', 'pisa',
  'lucca', 'como', 'rimini', 'perugia', 'parma', 'modena', 'ravenna',
  'lecce', 'bari', 'alberobello', 'matera', 'sorrento', 'positano',
  'taormina', 'catania', 'trieste', 'padua', 'arezzo', 'varenna',
  'san gimignano', 'portofino', 'bellagio', 'orvieto', 'assisi', 'cortona',
  'new york', 'los angeles', 'san francisco', 'las vegas', 'miami',
  'chicago', 'boston', 'new orleans', 'nashville', 'savannah',
  'charleston', 'minneapolis', 'seattle', 'portland', 'honolulu',
  'sri lanka', 'italy', 'france', 'greece', 'japan', 'indonesia',
  'martinique', 'cebu', 'jakarta', 'guayaquil', 'galle', 'sigiriya',
  'aberdeen', 'whitby', 'salzburg', 'heidelberg', 'avignon',
  'nagasaki', 'hiroshima', 'chiang mai', 'phuket', 'ubud',
  'cancun', 'tulum', 'oaxaca', 'cusco', 'cartagena', 'medellin',
]);

const MODIFIER_WORDS = new Set([
  'private', 'guided', 'small', 'group', 'exclusive', 'luxury', 'vip',
  'half', 'full', 'day', 'morning', 'afternoon', 'evening', 'night',
  'sunset', 'sunrise', 'skip', 'the', 'line', 'hour', 'hours',
  'minute', 'minutes', 'premium', 'ultimate', 'best', 'top',
  'express', 'deluxe', 'classic', 'original', 'official',
  'ticket', 'tickets', 'entry', 'admission', 'pass',
]);

const FILLER_WORDS = new Set([
  'the', 'a', 'an', 'with', 'for', 'from', 'to', 'and', 'or',
  'in', 'at', 'on', 'of', 'by', 'your', 'our', 'this', 'that',
]);

function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function extractCity(name: string): string | null {
  const nl = name.toLowerCase();
  let best: string | null = null;
  let bestLen = 0;
  for (const d of KNOWN_DESTINATIONS) {
    if (d.length > bestLen && nl.includes(d)) {
      const regex = new RegExp(`\\b${escapeRegex(d)}\\b`, 'i');
      if (regex.test(nl)) { best = d; bestLen = d.length; }
    }
  }
  if (best) return best.split(' ').map(w => w[0]!.toUpperCase() + w.slice(1)).join(' ');

  // Pattern fallback
  const inMatch = name.match(/\bin\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\s*$/);
  if (inMatch?.[1] && inMatch[1].length >= 3 && inMatch[1].length <= 30) return inMatch[1];
  const colonMatch = name.match(/^([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*):\s/);
  if (colonMatch?.[1] && colonMatch[1].length >= 3 && colonMatch[1].length <= 30) return colonMatch[1];

  return null;
}

function extractActivity(name: string, cities: Set<string>): string | null {
  let n = name.toLowerCase();
  for (const city of cities) {
    n = n.replace(new RegExp(`\\b${escapeRegex(city.toLowerCase())}\\b`, 'g'), ' ');
  }
  n = n.replace(/[-–—]/g, ' ').replace(/[^a-z\s]/g, '');
  let words = n.split(/\s+/).filter(w => w.length > 0);
  words = words.filter(w => !MODIFIER_WORDS.has(w) && !FILLER_WORDS.has(w) && w.length > 1);
  words = words.filter(w => !/^\d+h?o?u?r?s?$/.test(w));
  const phrase = words.join(' ').trim();
  const wc = phrase.split(/\s+/).length;
  if (wc < 2 || wc > 5) return null;
  return phrase;
}

function isTransfer(product: HolibobProduct): boolean {
  const cats = (product.categoryList?.nodes || []).map((n: any) => n.name).filter(Boolean);
  if (cats.length === 0) return false;
  const expCats = cats.filter((c: string) => !TRANSPORT_CATEGORIES.has(c.toLowerCase()));
  if (expCats.length === 0) return true;
  const nameLower = product.name.toLowerCase();
  if (cats.some((c: string) => c.toLowerCase() === 'transfer') &&
      (/\btransfer\b/.test(nameLower) || /\bairport\s+(to|from)\b/.test(nameLower))) {
    return true;
  }
  return false;
}

async function main() {
  const count = parseInt(process.argv[2] || '10', 10);

  const client = createHolibobClient({
    apiUrl: process.env['HOLIBOB_API_URL']!,
    partnerId: process.env['HOLIBOB_PARTNER_ID']!,
    apiKey: process.env['HOLIBOB_API_KEY']!,
    apiSecret: process.env['HOLIBOB_API_SECRET'],
  });

  const suppliers = await prisma.supplier.findMany({
    where: { microsite: { status: 'ACTIVE' } },
    select: { id: true, holibobSupplierId: true, name: true },
    orderBy: { productCount: 'desc' },
    take: count,
  });

  const allSeeds = new Set<string>();

  for (const sup of suppliers) {
    const resp = await client.getProductsByProvider(sup.holibobSupplierId, { pageSize: 20 });
    const products = resp.nodes;

    const expProducts = products.filter(p => !isTransfer(p));
    const ratio = products.length > 0 ? expProducts.length / products.length : 0;

    if (ratio < 0.15) {
      console.log(`\n[SKIP] ${sup.name} (${products.length} products, ${(ratio*100).toFixed(0)}% experiences)`);
      continue;
    }

    const cities = new Set<string>();
    const activities = new Set<string>();

    for (const p of expProducts) {
      const city = extractCity(p.name);
      if (city) cities.add(city);
    }

    for (const p of expProducts) {
      const act = extractActivity(p.name, cities);
      if (act) activities.add(act);
    }

    const seeds: string[] = [];
    for (const act of activities) {
      for (const city of cities) {
        seeds.push(`${act} in ${city}`.toLowerCase());
      }
    }

    console.log(`\n[KEEP] ${sup.name} (${products.length} products, ${(ratio*100).toFixed(0)}% exp)`);
    console.log(`  Cities: [${[...cities].join(', ')}]`);
    console.log(`  Activities: [${[...activities].slice(0, 8).join(', ')}]`);
    console.log(`  Sample seeds (${seeds.length} total):`);
    for (const s of seeds.slice(0, 10)) {
      console.log(`    • ${s}`);
      allSeeds.add(s);
    }
  }

  console.log(`\n\n=== SUMMARY ===`);
  console.log(`Total unique seeds across all suppliers: ${allSeeds.size}`);
  console.log(`\nSample of all seeds (first 30):`);
  const sorted = [...allSeeds].sort();
  for (const s of sorted.slice(0, 30)) {
    console.log(`  ${s}`);
  }

  await prisma.$disconnect();
}

main().catch(e => {
  console.error('ERROR:', e.message);
  process.exit(1);
});
