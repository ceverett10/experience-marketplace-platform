import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getSiteRoadmap, TASK_DESCRIPTIONS } from '@experience-marketplace/jobs';

export async function GET(request: Request, { params }: { params: Promise<{ id: string }> }) {
  try {
    const { id } = await params;

    // Fetch site with all related data
    const site = await prisma.site.findUnique({
      where: { id },
      select: {
        id: true,
        name: true,
        slug: true,
        description: true,
        status: true,
        isAutomatic: true,
        autonomousProcessesPaused: true,
        pauseReason: true,
        primaryDomain: true,
        gscVerified: true,
        gscVerifiedAt: true,
        seoConfig: true, // Include brand identity data
        homepageConfig: true, // Include homepage configuration
        createdAt: true,
        updatedAt: true,
        publishedAt: true,
        brand: true,
        domains: true,
        pages: {
          orderBy: { createdAt: 'desc' },
        },
        jobs: {
          orderBy: { createdAt: 'desc' },
          take: 50, // Limit to recent jobs
        },
        opportunities: true,
        _count: {
          select: {
            pages: true,
            content: true,
            bookings: true,
          },
        },
      },
    });

    if (!site) {
      return NextResponse.json({ error: 'Site not found' }, { status: 404 });
    }

    // Format jobs for display
    const formattedJobs = site.jobs.map((job) => ({
      id: job.id,
      type: job.type,
      status: job.status,
      priority: job.priority,
      attempts: job.attempts,
      maxAttempts: job.maxAttempts,
      error: job.error,
      result: job.result,
      scheduledFor: job.scheduledFor?.toISOString() || null,
      startedAt: job.startedAt?.toISOString() || null,
      completedAt: job.completedAt?.toISOString() || null,
      createdAt: job.createdAt.toISOString(),
    }));

    // Group jobs by status for summary
    const jobSummary = {
      total: site.jobs.length,
      pending: site.jobs.filter((j) => j.status === 'PENDING').length,
      running: site.jobs.filter((j) => j.status === 'RUNNING').length,
      completed: site.jobs.filter((j) => j.status === 'COMPLETED').length,
      failed: site.jobs.filter((j) => j.status === 'FAILED').length,
    };

    // Get site roadmap with phases
    const roadmap = await getSiteRoadmap(id);

    return NextResponse.json({
      site: {
        id: site.id,
        name: site.name,
        slug: site.slug,
        description: site.description,
        status: site.status,
        isAutomatic: site.isAutomatic,
        autonomousProcessesPaused: site.autonomousProcessesPaused,
        pauseReason: site.pauseReason,
        primaryDomain: site.primaryDomain,
        suggestedDomain: site.primaryDomain || `${site.slug}.com`,
        gscVerified: site.gscVerified,
        gscVerifiedAt: site.gscVerifiedAt?.toISOString() || null,
        seoConfig: site.seoConfig, // Brand identity data (tone of voice, trust signals, brand story)
        homepageConfig: site.homepageConfig, // Homepage configuration (hero, experiences query, destinations)
        createdAt: site.createdAt.toISOString(),
        updatedAt: site.updatedAt.toISOString(),
        publishedAt: site.publishedAt?.toISOString() || null,
        brand: site.brand
          ? {
              id: site.brand.id,
              name: site.brand.name,
              tagline: site.brand.tagline,
              primaryColor: site.brand.primaryColor,
              secondaryColor: site.brand.secondaryColor,
              accentColor: site.brand.accentColor,
              headingFont: site.brand.headingFont,
              bodyFont: site.brand.bodyFont,
              logoUrl: site.brand.logoUrl,
              isAutoGenerated: site.brand.isAutoGenerated,
            }
          : null,
        domains: site.domains.map((d) => ({
          id: d.id,
          domain: d.domain,
          status: d.status,
          verifiedAt: d.verifiedAt?.toISOString() || null,
          sslEnabled: d.sslEnabled,
        })),
        pages: site.pages.map((p) => ({
          id: p.id,
          title: p.title,
          slug: p.slug,
          type: p.type,
          status: p.status,
        })),
        counts: site._count,
      },
      jobs: formattedJobs,
      jobSummary,
      roadmap,
    });
  } catch (error) {
    console.error('[API] Error fetching site:', error);
    return NextResponse.json({ error: 'Failed to fetch site' }, { status: 500 });
  }
}
