import { describe, it, expect, vi, beforeEach } from 'vitest';
import { mockPrisma } from '@/test/mocks/prisma';
import { mockGetSiteRoadmap } from '@/test/mocks/jobs';
import { createMockSiteWithRelations, createMockBrand, createMockDomain } from '@/test/factories';
import { createMockJob } from '@/test/factories';

vi.mock('@/lib/prisma', () => ({
  prisma: mockPrisma,
}));

vi.mock('@experience-marketplace/jobs', () => ({
  getSiteRoadmap: mockGetSiteRoadmap,
  TASK_DESCRIPTIONS: {
    CONTENT_GENERATE: 'Generate content',
    SEO_ANALYZE: 'Analyze SEO',
    SITE_CREATE: 'Create site',
  },
}));

import { GET } from './route';

function createRequest(url: string) {
  return new Request(url);
}

function createParams(id: string) {
  return { params: Promise.resolve({ id }) };
}

describe('GET /api/sites/[id]', () => {
  it('returns comprehensive site data with relations', async () => {
    const brand = createMockBrand({ id: 'brand-1', name: 'Adventure Co' });
    const domain = createMockDomain({
      id: 'domain-1',
      domain: 'adventure.com',
      status: 'ACTIVE',
      sslEnabled: true,
      verifiedAt: new Date('2024-02-01'),
    });
    const job = createMockJob({
      id: 'job-1',
      type: 'CONTENT_GENERATE',
      status: 'COMPLETED',
      scheduledFor: null,
      startedAt: new Date('2024-01-20T10:00:00Z'),
      completedAt: new Date('2024-01-20T10:05:00Z'),
      createdAt: new Date('2024-01-20T10:00:00Z'),
    });

    const site = createMockSiteWithRelations({
      id: 'site-1',
      name: 'Adventure Tours',
      slug: 'adventure-tours',
      brand,
      domains: [domain],
      pages: [
        {
          id: 'page-1',
          title: 'Homepage',
          slug: 'homepage',
          type: 'HOMEPAGE',
          status: 'PUBLISHED',
          createdAt: new Date('2024-01-15'),
        },
      ],
      jobs: [job],
      opportunities: [],
      _count: { pages: 5, content: 3, bookings: 12 },
      gscVerified: true,
      gscVerifiedAt: new Date('2024-02-15'),
      publishedAt: new Date('2024-03-01'),
      seoConfig: { toneOfVoice: { personality: ['Professional'] } },
      homepageConfig: { hero: { title: 'Welcome' } },
    });

    mockPrisma.site.findUnique.mockResolvedValue(site);
    mockGetSiteRoadmap.mockResolvedValue([
      { phase: 1, name: 'Setup', status: 'COMPLETED', tasks: [] },
    ]);

    const response = await GET(
      createRequest('http://localhost/api/sites/site-1'),
      createParams('site-1')
    );
    const data = await response.json();

    expect(response.status).toBe(200);

    // Site fields
    expect(data.site.id).toBe('site-1');
    expect(data.site.name).toBe('Adventure Tours');
    expect(data.site.slug).toBe('adventure-tours');
    expect(data.site.gscVerified).toBe(true);
    expect(data.site.gscVerifiedAt).toBe('2024-02-15T00:00:00.000Z');
    expect(data.site.publishedAt).toBe('2024-03-01T00:00:00.000Z');
    expect(data.site.seoConfig).toEqual({ toneOfVoice: { personality: ['Professional'] } });
    expect(data.site.homepageConfig).toEqual({ hero: { title: 'Welcome' } });

    // Brand
    expect(data.site.brand).toEqual({
      id: 'brand-1',
      name: 'Adventure Co',
      tagline: expect.any(String),
      primaryColor: expect.any(String),
      secondaryColor: expect.any(String),
      accentColor: expect.any(String),
      headingFont: expect.any(String),
      bodyFont: expect.any(String),
      logoUrl: null,
      isAutoGenerated: true,
    });

    // Domains
    expect(data.site.domains).toHaveLength(1);
    expect(data.site.domains[0].domain).toBe('adventure.com');
    expect(data.site.domains[0].sslEnabled).toBe(true);

    // Pages
    expect(data.site.pages).toHaveLength(1);
    expect(data.site.pages[0]).toEqual({
      id: 'page-1',
      title: 'Homepage',
      slug: 'homepage',
      type: 'HOMEPAGE',
      status: 'PUBLISHED',
    });

    // Counts
    expect(data.site.counts).toEqual({ pages: 5, content: 3, bookings: 12 });

    // Jobs
    expect(data.jobs).toHaveLength(1);
    expect(data.jobs[0].id).toBe('job-1');
    expect(data.jobs[0].status).toBe('COMPLETED');
    expect(data.jobs[0].startedAt).toBe('2024-01-20T10:00:00.000Z');
    expect(data.jobs[0].completedAt).toBe('2024-01-20T10:05:00.000Z');

    // Job summary
    expect(data.jobSummary).toEqual({
      total: 1,
      pending: 0,
      running: 0,
      completed: 1,
      failed: 0,
    });

    // Roadmap
    expect(data.roadmap).toHaveLength(1);
    expect(data.roadmap[0].phase).toBe(1);
  });

  it('returns 404 when site does not exist', async () => {
    mockPrisma.site.findUnique.mockResolvedValue(null);

    const response = await GET(
      createRequest('http://localhost/api/sites/nonexistent'),
      createParams('nonexistent')
    );
    const data = await response.json();

    expect(response.status).toBe(404);
    expect(data.error).toBe('Site not found');
  });

  it('handles site with no brand', async () => {
    const site = createMockSiteWithRelations({
      brand: null,
      brandId: null,
    });
    mockPrisma.site.findUnique.mockResolvedValue(site);

    const response = await GET(
      createRequest('http://localhost/api/sites/site-1'),
      createParams('site-1')
    );
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.site.brand).toBeNull();
  });

  it('suggests domain from slug when no primary domain', async () => {
    const site = createMockSiteWithRelations({
      slug: 'london-adventures',
      primaryDomain: null,
    });
    mockPrisma.site.findUnique.mockResolvedValue(site);

    const response = await GET(
      createRequest('http://localhost/api/sites/site-1'),
      createParams('site-1')
    );
    const data = await response.json();

    expect(data.site.suggestedDomain).toBe('london-adventures.com');
  });

  it('computes job summary correctly from mixed statuses', async () => {
    const jobs = [
      createMockJob({ status: 'PENDING', startedAt: null, completedAt: null }),
      createMockJob({ status: 'PENDING', startedAt: null, completedAt: null }),
      createMockJob({ status: 'RUNNING', completedAt: null }),
      createMockJob({ status: 'COMPLETED' }),
      createMockJob({ status: 'COMPLETED' }),
      createMockJob({ status: 'COMPLETED' }),
      createMockJob({ status: 'FAILED', completedAt: null, error: 'timeout' }),
    ];

    const site = createMockSiteWithRelations({ jobs });
    mockPrisma.site.findUnique.mockResolvedValue(site);

    const response = await GET(
      createRequest('http://localhost/api/sites/site-1'),
      createParams('site-1')
    );
    const data = await response.json();

    expect(data.jobSummary).toEqual({
      total: 7,
      pending: 2,
      running: 1,
      completed: 3,
      failed: 1,
    });
  });

  it('returns 500 when database fails', async () => {
    mockPrisma.site.findUnique.mockRejectedValue(new Error('Connection timeout'));

    const response = await GET(
      createRequest('http://localhost/api/sites/site-1'),
      createParams('site-1')
    );
    const data = await response.json();

    expect(response.status).toBe(500);
    expect(data.error).toBe('Failed to fetch site');
  });

  it('handles null optional date fields in serialization', async () => {
    const site = createMockSiteWithRelations({
      gscVerifiedAt: null,
      publishedAt: null,
      jobs: [
        createMockJob({
          scheduledFor: null,
          startedAt: null,
          completedAt: null,
          status: 'PENDING',
        }),
      ],
      domains: [createMockDomain({ verifiedAt: null })],
    });
    mockPrisma.site.findUnique.mockResolvedValue(site);

    const response = await GET(
      createRequest('http://localhost/api/sites/site-1'),
      createParams('site-1')
    );
    const data = await response.json();

    expect(response.status).toBe(200);
    expect(data.site.gscVerifiedAt).toBeNull();
    expect(data.site.publishedAt).toBeNull();
    expect(data.jobs[0].scheduledFor).toBeNull();
    expect(data.jobs[0].startedAt).toBeNull();
    expect(data.jobs[0].completedAt).toBeNull();
    expect(data.site.domains[0].verifiedAt).toBeNull();
  });
});
